## 메서드 오버로딩, 오버라이딩

오늘 수업을 듣다가 교수님께서 다음과 같은 언급을 하셨다. 여러가지 언급들도 많았지만 Functional Overloading, Functional Overriding관련 얘기를 하셨다. 그러고 나서 들어보니 결국 자바에서 사용하는 메서드 오버로딩, 메서드 오버라이딩이랑 거의 똑같은 개념이어서 다시 정리하게 되었다.

### 두 개의 가장 큰 차이는 상속이다!!

물론 개념적으로 여러 차이도 있긴 하지만 핵심은 상속이 되었는지에 대한 차이가 가장 중요한 것이라고 말씀해주셨다.

- 메서드 오버로딩: 상속이 되지 않아도 됨 `method signature`가 달라졌다면 오버로딩
- 메서드 오버라이딩 : 상속이 된 상태에서 `method signature`가 다르지 않게 사용한다면 오버라이딩


### 여기서 문제

```java
public class Parent {

    void foo(int a, int b) {
        return a;
    }

}

public class Child extends Parent {
    void foo(int a, int b, int c) {  // 이 친구는 오버로딩일까? 오버라이딩일까? 이 부분은 생각해보자.
    }
}


```

### method signature?

이 단어에 대해서는 오늘 처음 들어봤다. 어찌보면 너무 당연한 단어이지만 중요하게 생각을 하지 않은 것일 수도 있다고 생각했다.

> 메소드 시그니쳐 : 메서드 이름과 매개변수 리스트의 조합을 말한다.

**여기서 메서드 이름과 매개변수 리스트가 중요하다! 왜냐하면 `오버로딩` 때문이다. 항상 기준을 `메서드 시그니쳐`에 둔다.** 
- Java 컴파일러는 메서드 이름과 매개변수 리스트를 통해 메서드 간의 차이를 식별하기 때문이다.
  - 그러면 추가 질문? -> 리턴 타입은 왜 고려하지 않을까요?
    - 이 부분은 c++에서는 묵시적 형변환이 되기 때문에 컴파일러 입장에서는 나중에 형 변환시기에 고려하면 되서 고려하지 않는다고 한다.
    - 리턴 타입에 따라서는 어떤 메서드를 실행할지 결정할 수 없기 때문에 메서드의 리턴 타입을 오버로딩에서는 고려하지 않는다.
- 반환 유형이 다르더라도 시그니처가 동일한 두 메서드는 컴파일 타임 오류를 발생시킨다.



**그래서 너무 기본적인 내용이지만 확실하게 다시 되새기고 가면 좋을거 같다.**

### 출처
- https://www.tutorialspoint.com/Why-is-method-overloading-not-possible-by-changing-the-return-type-of-the-method-only-in-java
- https://fordeveloper2.tistory.com/4952
- 학교 수업(컴퓨터 비전)